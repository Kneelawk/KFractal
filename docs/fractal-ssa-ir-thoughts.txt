Programs contain functions and global variables.
Every function is referenced by its index within the program.
Every global variable is referenced by the global scope and its index within the global scope.

Every variable MUST be initialized with a value.

Functions contain:
 * A return type
 * Argument list
 * BasicBlock list

Every argument is referenced by the argument list scope and its index within the argument list.
Every basic block is referenced by its index within the BasicBlock list.

BasicBlocks contain:
 * Instruction list

Every BasicBlock must end with a no-return control-flow instruction.
No-return control-flow instructions include:
 * Return (returns from the current function)
 * Jump (unconditionally jumps to another BasicBlock within this function)
 * ConditionalJump (conditionally jumps to another BasicBlock within this function)

All instructions in a BasicBlock's list should be kept in that order.
All instructions not in a BasicBlock's list (referenced only as values used in other instructions) could be performed in
any order.

When walking an instruction graph, care should be taken to recognize duplicate uses of an instruction, allowing its value
to be saved and re-used.

The Instructions that have a result value will also implement the Value interface.
Constants and VariableReferences will also implement the Value interface.

How would I implement Phi instructions?
What a Phi instruction supposed to do is merging values from other BasicBlocks into a value that can be used in this
BasicBlock.
Should Phi even be instruction like other instructions?
Not if possible.
I actually don't see the problem.
CURRENT ISSUE: I do, the problem is when you're building a loop, how would you have a phi instruction referencing something that
references the phi instruction?

Maybe every instruction should have a reference to the BasicBlock it's in?
No, that shouldn't be necessary, because everything referenced by an instruction should be in the same BasicBlock as that
instruction and everything referenced by a phi instruction should be from a different block (which block is specified in
the phi instruction).
No Wait. What if an instruction referenced a value from another block that doesn't need to be merged with anything (
therefore no phi instruction)?
Does that prove that an instruction needs to know which BasicBlock it's in?
Not necessarily. If the instruction was only created in that other block then it isn't necessary for it to be there.
Unless it has side-effects. But if it has side-effects, it should already either have already been traversed when going
through that BasicBlock (either as a top-level instruction or as a dependency). Therefore it should already be
remembered by anything doing the traversing.

IDEA #1:
Instructions do not take other instructions as inputs. Rather, they take references to indices within their same BasicBlock.
These indices will be returned by a basic block from adding an instruction.
A Phi instruction takes both a basic block position reference and a basic block reference.

PROBLEM: This doesn't work if an instruction is referencing another instruction in another BasicBlock who's value is not
influenced by control-flow and therefore does not need to be passed through a Phi instruction.

IDEA #2:
Instructions directly take other instructions as inputs. This solves some of the referencing issues. If an instruction was
used in another BasicBlock, it will be remembered and therefore can have its result stored. Otherwise, it never needed to
be in that basic block in the first place.

The issue is that, due to the program structure's immutability, there is no way to have instruction variable use loops, even
when they should be there (like when using Phi instructions in control-flow loops).
    One way around this might be to have a special kind of reference that would be to a value that has not been defined yet.
    This kind of reference would only be accepted by Phi instructions.

    In fact, it might be a good idea to have Phi instructions only accept value references. There would be two kinds of
    value references, ones that have already been defined and ones that haven't.

Another issue is that because all instructions are encountered lazily, there is a chance that an instruction could end up
in a less-optimal position than its intent.
    This is not an issue because if an instruction were intended to be in a specific BasicBlock, it would be explicitly added
    to that BasicBlock and therefore remembered when the program structure is being walked.
